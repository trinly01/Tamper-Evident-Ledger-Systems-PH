# `talaan_chain` Collection Schema - Multi-Node Architecture

Collection schema for **distributed/multi-node** Talaan Chain system.

---

## Multi-Node Architecture Overview

```
┌─────────────────────┐   ┌─────────────────────┐   ┌─────────────────────┐
│   Node A (Manila)   │   │   Node B (Cebu)     │   │   Node C (Davao)    │
│                     │   │                     │   │                     │
│  id: abc-123 ←──────┼───┼─ Local DB ID       │   │  id: mno-345        │
│  talaan_id: SAME-ID │◄──┼─► talaan_id: SAME-ID│◄──┼─► talaan_id: SAME-ID│
│  current_hash: a1b2 │◄──┼─► current_hash: a1b2│◄──┼─► current_hash: a1b2│
└─────────────────────┘   └─────────────────────┘   └─────────────────────┘
         ▲                         ▲                         ▲
         │                         │                         │
         └─────────── Replicate ───┴───── Global Ledger ────┘
```

**Key Concept:**
- Each node has **different database IDs** (`id`)
- But **same ledger IDs** (`talaan_id`) for replicated entries
- Use `talaan_id` for inter-node communication and validation

---

## Field Definitions

| Field | Type | Scope | Description |
|-------|------|-------|-------------|
| `id` | UUID | **Local** | Database primary key (auto-generated, different per node) |
| **`talaan_id`** | UUID | **Global** | Global ledger entry ID (same across all nodes) ⭐ |
| **`parent_id`** | UUID | **Global** | References parent entry's `talaan_id` (NULL for genesis) ⭐ |
| `parent_hash` | String(8) | **Global** | Hash of parent entry |
| `current_hash` | String(8) | **Global** | Hash of this entry |
| `payload` | JSON | **Global** | Event data |
| `date_created` | Timestamp | **Local** | When created on this node |

---

## Why Use `talaan_id` Instead of Just `id`?

### Problem: Replicating Across Nodes

```javascript
// ❌ Problem: Using only database IDs
Node A creates:
{
  id: "abc-123",              // Directus auto-generates this
  parent_id: "xyz-789",       // References parent's id
  current_hash: "a1b2c3d4"
}

// When Node B receives this entry, it inserts into its database:
{
  id: "def-456",              // ❌ Different ID! Directus generates NEW UUID
  parent_id: "xyz-789",       // ❌ This parent ID doesn't exist in Node B!
  current_hash: "a1b2c3d4"
}
// ❌ Chain is broken on Node B because parent_id is invalid!
```

### ✅ Solution: Global Ledger IDs

```javascript
// ✅ Solution: Using talaan_id
Node A creates:
{
  id: "abc-123",                      // Local DB ID
  talaan_id: "GLOBAL-UUID",           // ✅ Generated once, stays same
  parent_talaan_id: "PARENT-GLOBAL-UUID", // ✅ Global reference
  current_hash: "a1b2c3d4"
}

// When Node B receives this:
{
  id: "def-456",                      // Different local ID (OK!)
  talaan_id: "GLOBAL-UUID",           // ✅ Same ledger ID!
  parent_talaan_id: "PARENT-GLOBAL-UUID", // ✅ Same global parent!
  current_hash: "a1b2c3d4"
}
// ✅ Chain integrity maintained! We can find parent by talaan_id
```

---

## Directus Collection Setup

### Step 1: Create Collection
Same as single-node setup.

### Step 2: Add `talaan_id` Field ⭐

1. **Type:** UUID
2. **Field Name:** `talaan_id`
3. **Interface:** Input (UUID)
4. **Schema:**
   - Nullable: ❌ No
   - Unique: ✅ Yes (globally unique ledger ID)
   - Auto-generate: ✅ Yes (Directus auto-generates UUID, just like `id`)
5. **Validation:**
   - Pattern: `^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`
6. **Display:**
   - Font: Monospace
   - Read-only in UI
7. **Index:** ✅ Yes (critical for lookups)
8. Save

**Note:** `talaan_id` is auto-generated by Directus just like the primary key `id`.

### Step 3: Add `parent_id` Field ⭐

1. **Type:** UUID
2. **Field Name:** `parent_id`
3. **Interface:** Input (UUID)
4. **Schema:**
   - Nullable: ✅ Yes (NULL for genesis)
   - Unique: ❌ No (multiple children can have same parent)
   - **No foreign key constraint** (references another entry's `talaan_id`, NOT the database `id`)
5. **Display:**
   - Font: Monospace
6. **Index:** ✅ Yes (for parent lookups)
7. Save

**Important:** `parent_id` references the `talaan_id` field of the parent entry, NOT the database `id`!

### Step 4-7: Add Hash and Payload Fields
- `parent_hash` (String)
- `current_hash` (String)
- `payload` (JSON)
- System fields (date_created, user_created, etc.)

---

## Example Data - Multi-Node

### Genesis Entry (Created on Node A)

**Node A (Manila):**
```json
{
  "id": "aaa-111",
  "talaan_id": "genesis-global-uuid-123",
  "parent_id": null,
  "parent_hash": "likha_genesis",
  "current_hash": "c8ab12d2",
  "payload": {...}
}
```

**Node B (Cebu) - After Replication:**
```json
{
  "id": "bbb-222",                        // ← Different local ID
  "talaan_id": "genesis-global-uuid-123", // ✅ Same talaan_id!
  "parent_id": null,
  "parent_hash": "likha_genesis",
  "current_hash": "c8ab12d2",             // ✅ Same hash!
  "payload": {...}                        // ✅ Same payload!
}
```

### Child Entry (Created on Node B)

**Node B (Cebu):**
```json
{
  "id": "bbb-333",
  "talaan_id": "child-global-uuid-456",
  "parent_id": "genesis-global-uuid-123", // ← References parent's talaan_id
  "parent_hash": "c8ab12d2",
  "current_hash": "eb1a19a0",
  "payload": {...}
}
```

**Node A (Manila) - After Replication:**
```json
{
  "id": "aaa-222",                        // ← Different local ID
  "talaan_id": "child-global-uuid-456",   // ✅ Same talaan_id!
  "parent_id": "genesis-global-uuid-123", // ✅ Same parent reference!
  "parent_hash": "c8ab12d2",
  "current_hash": "eb1a19a0",
  "payload": {...}
}
```

---

## Validation in Multi-Node

### Use `talaan_id` for Validation

```javascript
// ✅ Good: Validate using talaan_id
function validateEntry(entry, entryMap) {
  // Check if genesis
  if (!entry.parent_id) {
    return entry.parent_hash === 'likha_genesis' 
      ? { valid: true } 
      : { valid: false, code: 'GENESIS_HASH_INVALID' };
  }
  
  // Find parent using parent_id (which stores parent's talaan_id)
  const parent = entryMap[entry.parent_id];
  
  if (!parent) {
    return {
      valid: false,
      code: 'PARENT_NOT_FOUND',
      message: `Parent ${entry.parent_id} not found`
    };
  }
  
  // Verify parent hash matches
  if (parent.current_hash !== entry.parent_hash) {
    return {
      valid: false,
      code: 'PARENT_HASH_MISMATCH'
    };
  }
  
  return { valid: true };
}

// Build entry map using talaan_id (global identifier)
const entryMap = {};
entries.forEach(entry => {
  entryMap[entry.talaan_id] = entry;
});
```

### ❌ Don't Use `id` for Cross-Node Validation

```javascript
// ❌ Bad: Using local database IDs
const parent = entryMap[entry.parent_id]; // Different per node!
```

---

## Replication Strategy

### Step 1: Export Entry (Node A)
```json
{
  "talaan_id": "global-uuid",
  "parent_id": "parent-global-uuid",
  "parent_hash": "a1b2c3d4",
  "current_hash": "e5f6g7h8",
  "payload": {...}
}
```

### Step 2: Import to Node B
```javascript
// Check if already exists
const existing = await directus.items('talaan_chain')
  .readByQuery({
    filter: { talaan_id: { _eq: data.talaan_id } },
    limit: 1
  });

if (existing && existing.length > 0) {
  // Verify integrity
  if (existing[0].current_hash !== data.current_hash) {
    throw new Error('Hash mismatch - data corruption!');
  }
  return; // Already synced
}

// Insert with new local ID but same global identifiers
await directus.items('talaan_chain').createOne({
  // id: auto-generated by Directus (new local ID)
  talaan_id: data.talaan_id,      // Keep same ✅
  parent_id: data.parent_id,      // Keep same ✅
  parent_hash: data.parent_hash,  // Keep same ✅
  current_hash: data.current_hash,// Keep same ✅
  payload: data.payload           // Keep same ✅
});
```

---

## Query Examples

### Query by Local ID (Fast, Single Entry)
```javascript
// ✅ Use when you know the database ID
const entry = await directus.items('talaan_chain').readOne(localId);
```

### Query by Global ID (Cross-Node Lookups)
```javascript
// ✅ Use for validation, replication, and parent lookups
const entry = await directus.items('talaan_chain')
  .readByQuery({
    filter: { talaan_id: { _eq: globalTalaanId } },
    limit: 1
  });

// Verify entry exists on all nodes
const exists = entry && entry.length > 0;
```

### Query Children (Find entries pointing to this parent)
```javascript
// ✅ Find all children of a specific entry
const children = await directus.items('talaan_chain')
  .readByQuery({
    filter: { parent_id: { _eq: parentTalaanId } }
  });
```

### Latest Entries (Use date_created)
```javascript
// ✅ Chronological order
const latest = await directus.items('talaan_chain')
  .readByQuery({
    sort: ['-date_created'],
    limit: 50
  });
```

---

## Indexes for Multi-Node

```sql
-- Primary key (auto-created)
-- CREATE UNIQUE INDEX idx_talaan_chain_id ON talaan_chain(id);

-- Global ledger ID (critical for cross-node lookups)
CREATE UNIQUE INDEX idx_talaan_chain_talaan_id ON talaan_chain(talaan_id);

-- Parent lookups (find children, trace chain)
CREATE INDEX idx_talaan_chain_parent_id ON talaan_chain(parent_id);

-- Hash lookups (validation)
CREATE INDEX idx_talaan_chain_current_hash ON talaan_chain(current_hash);
CREATE INDEX idx_talaan_chain_parent_hash ON talaan_chain(parent_hash);

-- Chronological queries (latest entries)
CREATE INDEX idx_talaan_chain_date_created ON talaan_chain(date_created);
```

---

## Migration from Single-Node

If you already have single-node setup without `talaan_id`:

```sql
-- Add new field
ALTER TABLE talaan_chain 
ADD COLUMN talaan_id UUID UNIQUE;

-- Backfill talaan_id with new UUIDs
UPDATE talaan_chain 
SET talaan_id = gen_random_uuid()
WHERE talaan_id IS NULL;

-- If you have existing parent_id that references database id, 
-- you'll need to update it to reference talaan_id instead
-- This is complex - best to start fresh or manually migrate

-- Create indexes
CREATE UNIQUE INDEX idx_talaan_chain_talaan_id ON talaan_chain(talaan_id);
CREATE INDEX idx_talaan_chain_parent_id ON talaan_chain(parent_id);
```

---

## Best Practices

1. ✅ **Always use `talaan_id`** for replication and validation
2. ✅ **`parent_id` stores parent's `talaan_id`**, not database `id`
3. ✅ **Generate `talaan_id` once** at creation, never change it
4. ✅ **Verify `current_hash` matches** during replication (detect tampering)
5. ✅ **Index `talaan_id` and `parent_id`** for fast queries
6. ❌ **Never use database `id` for parent references** - it's different per node!
7. ❌ **Never expose local `id`** in APIs between nodes

---

## Summary

| Field | Single-Node | Multi-Node | Replicated? | Purpose |
|-------|-------------|------------|-------------|---------|
| `id` | Primary key | Primary key (local) | ❌ No | Database operations |
| `talaan_id` | ❌ Not needed | ✅ Required (global) | ✅ Yes | Cross-node identity |
| `parent_id` | ❌ Not needed | ✅ Required (global) | ✅ Yes | Stores parent's `talaan_id` |
| `parent_hash` | Required | Required | ✅ Yes | Integrity validation |
| `current_hash` | Required | Required | ✅ Yes | Entry integrity |
| `payload` | Required | Required | ✅ Yes | Event data |
| `date_created` | Auto | Auto | ❌ No | Timestamp |

---

**Status:** ✅ Production Ready for Multi-Node  
**Version:** 2.0 (Multi-Node)  
**Last Updated:** 2025-10-10

